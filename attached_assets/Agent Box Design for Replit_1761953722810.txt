0) Landing page (AgentBox)Goal: convince both sides (Sellers & Buyers) to use AgentBox emails so their agents can qualify fit and auto-schedule only when it’s worth it.HeroHeadline: Stop wasting meetings.Subhead: AgentBox lets your email act like you—qualify fit, ask clarifying questions, and book meetings only when there’s a match.Primary CTA: Get your AgentBox email →Secondary CTA: See a live two-agent demo →Why Sellers• Fewer no-shows, better win rates — only qualified buyers make it to your calendar.• Automatic discovery & follow-ups — your agent asks missing questions, nudges respectfully, and closes loops.• Faster handoffs — summary + CRM-ready notes in every thread.Why Buyers• No pitch spam — your agent filters inbound sellers to your criteria.• One-email intake — the agent gathers details from the seller so you don’t have to.• Calendars respected — meetings happen only when there’s clear value.How it works (3 steps)1. Claim your @agentbox.ai address (e.g., aria@agentbox.ai).2. Set preferences (industry, company size, budget, timing, tools).3. Email another AgentBox address — the agents converse, score fit, and book only if above threshold.Social proof / Trust• Built on modern agent infra; works with your calendar & CRM.• You’re always bCC’d for preselected stages; one-click “pause/override.”• Data stays in your workspace; export any time.Footer• Pricing (free during beta), Docs, Directory, FAQ, Contact.1) Discovery: how a seller finds a buyer’s AgentBox emailYou need something that works today in a hackathon. Use a simple, layered approach:LinkedIn placement (fastest to demo)Ask users to add their AgentBox email in:• LinkedIn Contact info (Email)• And optionally in the Headline (“Chat with my agent: aria@agentbox.ai”)Demo: click a sample LinkedIn profile screenshot → copy address → start the agent thread.2) Side-by-side email clients (conversation viewer)One page, two columns:• Left column: Seller inbox (e.g., pete@agentbox.ai) view of the thread• Right column: Buyer inbox (e.g., aria@agentbox.ai) view of the same thread• Each message shows: from, to, subject, time, and message body.• Live update: poll your backend every 2–3s (or use Convex live queries) to render new messages.• Controls bar (top): Start demo thread, Toggle “Ask a clarifying question,” Force low/high score, Reset.Implementation notes (Replit)• Single Node/Express app.• /public for static HTML (TailwindCDN for speed).• /api/threads/:id returns normalized messages (direction, sender, body).• Keep a tiny ThreadState store (in Convex or local JSON) and append messages as your webhook fires.3) Middle-agent (fit scoring + clarify + schedule)Flow (event-driven)1. Inbound email to pete@ or aria@ → webhook hits POST /webhooks/agentmail with message + threadId.2. Load profiles for both sides; extract signals (industry, size, geo, intent, timing, budget, authority, stack).3. Compute score (weighted sum).4. Decision:o If score ≥ threshold_meet → propose 2–3 slots and (optionally) place a hold on acceptance.o If threshold_clarify ≤ score < threshold_meet → send one clarifying question for missing signals.o If score < threshold_clarify → polite decline (or share resources).5. Writeback summary to the thread + store in state for the dashboard.Data model (minimal)SellerProfile: { handle, company, website, industry: string[], sizeRange, geo, productCategories: string[], valueProps: string[], priceModel, icpRules: string[], disqualifiers: string[] }BuyerProfile:  { handle, company, website, industry: string[], sizeRange, geo, stackSignals: string[], budgetBand?: string, timing?: string, mustHave?: string[] }ThreadState:   { threadId, sellerHandle, buyerHandle, status: 'collecting'|'approved'|'declined'|'scheduled',                 lastScore: number, missing: string[], summary?: string, event?: { when, link } }ScoringConfig:{ weights: Record<string, number>, thresholdClarify: number, thresholdMeet: number }Signals (0–1 each)• industry_match, size_match, geo_match• need_intent (verbs/problems extracted from first buyer message)• timing, budget, authority (title from signature), stack_compatibility (keywords)Score = Σ weightᵢ × signalᵢEmail templates (plain + short)• Clarify: “To confirm fit, could you share your current [tool] and rough budget band?”• Approve: “Looks like a strong fit based on [signals]. Here are 3 times that work: [A/B/C]. Reply with A/B/C and I’ll confirm.”• Scheduled in calendar – show Composio scheduling• Decline: “Thanks for reaching out—based on [reasons], this likely isn’t a fit. Sharing a resource you may find useful: [link].”4) One-person build plan (Replit)Folder layout/index.html            # Landing page + Directory search/demo.html             # Side-by-side two-inbox viewer/server.ts             # Express app (webhooks + APIs + static)/lib/agentmail.ts      # sendEmail(), listThread(threadId), normalizeMessage()/lib/scoring.ts        # extractSignals(), score(), decide()/lib/store.ts          # in-memory or Convex bindings/seed/profiles.json    # sample Seller/Buyer profiles/public/               # CSS (Tailwind via CDN), logosKey endpoints• POST /webhooks/agentmail – handle inbound email → extract → score → decide → send reply → update store• GET /api/threads/:id – return normalized messages for left/right panes• POST /api/demo/start – seed a demo thread (first seller email)• POST /api/demo/force – set status to approved/clarify/decline (for live demo control)• GET /api/directory?q= – simple handle search for discovery flowSuggested tech choices (keep it simple)• DB: start with in-memory store (object in /lib/store.ts). If time allows, switch to Convex for realtime updates.• Auth: none needed for demo.• Scheduling: reply-based booking (A/B/C). If time remains, add a lightweight Google Calendar hold.What to show the judges (tight 90-sec flow)1. Landing page (two bullets each for Sellers/Buyers) → “Claim @agentbox.ai.”2. Directory → find “aria” → email opens to aria@agentbox.ai.3. Two-inbox demo: start thread; watch agents ask 1 clarifying q, rescore ≥ threshold, propose slots, buyer replies “B,” confirmation email + summary appears.4. Outcome card shows score + matched signals + scheduled time.5. Close with: “AgentBox stops low-value meetings and books the right ones automatically—via the inbox you already use.”AgentBox — ultra-simple solo build spec (Replit)Actors & emails• Seller agent: pete.b.seller@agentbox.ai• Buyer agent: aria.h.buyer@agentbox.aiStep 0 — BCC policy (owner visibility)• Rule: Only BCC human owners at the stage you select.o For demo, set bcc_stage = "confirm" (i.e., only when the meeting is confirmed).o Earlier stages (first reply / clarify) do not BCC owners.Implementation: a tiny helper// bcc.tsexport type BccStage = "never"|"clarify"|"confirm";export const BCC_STAGE: BccStage = "confirm";export function getBcc(stage: BccStage) {  return (BCC_STAGE === stage) ? ["owner@demo.invalid"] : []; // replace with real owner if desired}Use it only when sending the confirmation email.Step 1 — Discovery (Option A only)• LinkedIn placement: the prospect lists their AgentBox address (e.g., aria.h.buyer@agentbox.ai) in LinkedIn Contact info (and optionally headline).• Demo: your landing page has a mock LinkedIn card with a “Copy AgentBox Email” button that starts the flow.No directory, no resolver—keep it to Option A.Step 2 — Side-by-side email clients (two-pane viewer)• Left pane: thread as seen by pete.b.seller@…• Right pane: the same thread as seen by aria.h.buyer@…• Poll every 2–3s (or use Convex live query if you want).• Top controls: “Start demo thread”, “Reset”.Step 3 — Scheduling (must show calendar step)• On score ≥ threshold, the agent proposes A/B/C time slots.• When the buyer replies with “B”, you:1. Generate a real calendar event (use one of these, pick 1 for hackathon):• Simplest: create an ICS file on the server and send a link; both panes receive an email with the file attached + a page that renders event details (“Calendar step”).• Slightly fancier: generate a Google Calendar link (no OAuth) so clicking it opens the pre-filled event.• Stretch (optional): use Composio/Google API to place a hold automatically.2. Send confirmation email (this is where you BCC owners per Step 0).3. In the UI, show a Calendar card with: title, time, attendees, and links (“Add to Google/ICS”).Minimal data modeltype Party = "seller" | "buyer";type Status = "collecting" | "approved" | "declined" | "scheduled";interface Profile {  handle: string;             // "pete.b.seller" | "aria.h.buyer"  company: string;  industry: string[];  sizeRange: [number, number];  geo?: string;  stack?: string[];  budgetBand?: string;  timing?: string;  mustHave?: string[];}interface ThreadState {  threadId: string;  seller: Profile;  buyer: Profile;  status: Status;  lastScore: number;  missing: string[];  summary?: string;  event?: { whenISO: string; durationMins: number; title: string; icsUrl?: string; gcalUrl?: string };}Fit scoring (unchanged logic, tiny)Signals: industry_match, size_match, geo_match, intent, timing, budget, authority, stack_compatibilityScore = Σ(weights × signals)• ≥ thresholdMeet → propose slots• between → one clarifying email• < clarify → polite declineEmail templates (use exact addresses)Clarify (from aria.h.buyer@… to pete.b.seller@…):“Thanks for reaching out. To confirm fit, could you share your current [tool] and a rough budget band?”Approve w/ slots (from buyer to seller):“Looks like a strong fit based on [signals]. Here are three times:A) Tue 2:00–2:30 PM PTB) Wed 9:30–10:00 AM PTC) Thu 1:00–1:30 PM PTReply A/B/C and I’ll confirm.”Confirm (BCC owners here only):“Confirmed for [slot]. Calendar invite attached + link below. Summary: [1-para why it’s a fit].”Scheduling: two easy ways (pick one)A) ICS file (no OAuth, very reliable for demos)• Generate server-side and attach to the confirmation email; also host at /ics/:threadId.ics and link it.// schedule.ts (snippet)import ics from "ics";export function buildIcs({ title, whenISO, durationMins }: { title:string; whenISO:string; durationMins:number }) {  const start = new Date(whenISO);  const end = new Date(start.getTime() + durationMins*60000);  return new Promise<string>((resolve, reject) => {    ics.createEvent({      title,      start: [start.getFullYear(), start.getMonth()+1, start.getDate(), start.getHours(), start.getMinutes()],      end:   [end.getFullYear(),   end.getMonth()+1,   end.getDate(),   end.getHours(),   end.getMinutes()],      organizer: { name: "AgentBox", email: "noreply@agentbox.ai" },      attendees: [        { name: "Seller", email: "pete.b.seller@agentbox.ai" },        { name: "Buyer",  email: "aria.h.buyer@agentbox.ai"  }      ]    }, (err, value) => err ? reject(err) : resolve(value!));  });}B) Google Calendar quick-add link (no OAuth)• Build a URL like:https://calendar.google.com/calendar/r/eventedit?text=AgentBox%20Intro%20Call&dates=20251105T210000Z/20251105T213000Z&add=pete.b.seller@agentbox.ai,aria.h.buyer@agentbox.ai&details=Why%20this%20is%20a%20fit%3A%20...• Put that link in the confirmation email + show it in a “Calendar” panel in the UI.Endpoints (solo, minimal)POST /webhooks/agentmail   # inbound email → score → decide → reply (and maybe schedule)POST /api/demo/start       # seed first seller email (kick off thread)GET  /api/thread/:id       # normalized messages for left/right panesGET  /ics/:threadId.ics    # serve generated ICS (if using ICS approach)UI pages• / Landing: brief value prop + mock LinkedIn card with “Copy AgentBox Email” → launches demo• /demo Two-pane viewer:o Left: pete.b.seller@ viewo Right: aria.h.buyer@ viewo Top bar: Start / Reseto Bottom card: “Calendar” — shows selected slot + “Add to Google Calendar” link and/or “Download .ics”12-hour solo build checklist (Replit)1. Scaffold Express app + static pages (Tailwind via CDN).2. AgentMail: implement sendEmail(), webhook handler, in-memory ThreadState.3. Scoring: simple signal extractors, fixed weights, thresholds.4. Demo flow: /api/demo/start seeds first seller email; watcher updates panes.5. Scheduling: implement ICS (fastest) or GCal link; add BCC on confirm.6. Polish: landing copy, mock LinkedIn, three demo slots, reset button.Sponsor Tech Stack OverviewLayerTool / SponsorRole in AgentBoxWhy It Fits1. Core email infrastructure🟣 AgentMailProvides inboxes (pete.b.seller@agentbox.ai, aria.h.buyer@agentbox.ai), webhooks, and programmatic send/receiveCentral sponsor and the heart of the demo — all messages, threads, and BCC logic run through AgentMail2. Real-time state / memory backend🟢 Convex.devStores thread state, profiles, scores, and scheduling events with live query subscriptionsGives you persistent, reactive data in Replit; makes your two-pane UI auto-update as new messages arrive3. Reasoning / scoring layer(your choice of Mastra or a direct LLM API)Extracts signals (industry, budget, timing, etc.) and computes fit scoreMastra is a sponsor and gives you a lightweight orchestration wrapper for prompts; if you prefer, you can call OpenAI directly inside the Convex action4. Scheduling / automationComposio (optional stretch)If you want the “create calendar event” step to hit Google Calendar automaticallySponsor integration you can show even if you don’t use OAuth (Composio has pre-built Google connectors)5. Optional enrichment / tonePerplexity API (optional)Enrich company data before scoring (“what industry is Acme Inc?”)Adds extra sponsor touchpoint with minimal effort — one API call per thread6. Front-end hosting / devReplitRuns the full app (Express + Convex + Tailwind front-end)Official event co-sponsor — you’ll demo directly from your Replit URL💡 Minimal “sponsor-compliant” architecture (recommended)          ┌──────────────────────────┐          │        Front-end         │          │  (Replit + Tailwind UI)  │          └────────────┬─────────────┘                       │  live queries                 ┌──────▼──────┐                 │ Convex.dev  │◄────────────┐                 │ (profiles,  │             │                 │  threads)   │             │                 └──────┬──────┘             │         inbound email  │   state updates    │┌───────────────────────▼────────────────────┐│              AgentMail API                ││ send/receive + webhook → Convex mutation  │└───────────────────────┬────────────────────┘                        │                        │  LLM / Mastra actions                        ▼                Fit-scoring engine              (extract + compute score)                        │                        ├─► Composio (calendar)                        └─► Perplexity (optional enrichment)🔧 Quick summary of usage by sponsorSponsorVisible in Demo?Implementation effortNotesAgentMail✅ Core interaction (two-pane email thread)MediumYou’ll register 2 inboxes and a webhookConvex.dev✅ Live updates & memoryLow-mediumGreat docs; trivial to integrate in ReplitMastra (optional)✅ if you use it for reasoningLowSingle function call; highlight “Mastra orchestration”Composio (optional)✅ if you show calendar event auto-creationMediumAdds “calendar step” wow factorPerplexity (optional)✅ if you display “context from Perplexity” in fit summaryLowSimple HTTP call to fetch company contextReplit✅ Always—Hosts everything and powers live demo🚀 If you want maximum sponsor alignment (and minimal risk)Use this stack order:1. AgentMail → Convex.dev → Mastra(core 3, guaranteed working and good sponsor representation)2. Optional: Composio for scheduling if time allows.3. Optional: Perplexity enrichment call for extra polish.